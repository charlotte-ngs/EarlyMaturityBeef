---
title: "Design Function For Computations Of Economic Values and Index"
output: html_notebook
---


## Disclaimer

### Function Inputs
#### frequencies and thresholds
```{r conformationfreq}
#Vectors of animal numbers Carcass conformation (cc) 
#Angus (An) with a=stirks and c=calves.
Anccc <- c(2,2,35,278,634,708,298)
Ancca <- c(0,17,247,3459,8308,8857,5797)
#Limousin (Lm) with a=stirks and c=calves.
Lmccc <- c(3,2,17,88,300,838,2482)
Lmcca <- c(2,11,57,1041,6652,21092,56227)

#Shares Carcass conformation
#Angus with a=stirks and c=calves.
Anccc <- Anccc/sum(Anccc)
Ancca <- Ancca/sum(Ancca)
#Limousin with a=stirks and c=calves.
Lmccc <- Lmccc/sum(Lmccc)
Lmcca <- Lmcca/sum(Lmcca)

x <- data.frame(class = c("C", "H","T+","T","T-","A","X"), Anccc=Anccc,Ancca=Ancca,Lmccc=Lmccc,Lmcca=Lmcca)
kable(x,booktabs=T,digits=2, caption="Population frequencies accross carcass conformation classes (Kunz,2018)")
Anccc 
Ancca 
Lmccc 
Lmcca 
```

```{r fatfreq}
#Vectors of animal numbers Carcass fat 
#Angus with a=stirks and c=calves.
Ancfc <- c(189,706,935,125,2)
Ancfa <- c(802,3415,15673,6314,481)
#Limousin with a=stirks and c=calves.
Lmcfc <- c(735,1504,1419,72,0)
Lmcfa <- c(5102,21958,50705,7169,148)

#Shares Carcass fat
#Angus with a=stirks and c=calves.
Ancfc <- c(189,706,935,125,2)/sum(Ancfc)
Ancfa <- c(802,3415,15673,6314,481)/sum(Ancfa)
#Limousin with a=stirks and c=calves.
Lmcfc <- c(735,1504,1419,72,0)/sum(Lmcfc)
Lmcfa <- c(5102,21958,50705,7169,148)/sum(Lmcfa)

#Values Carcass fat classes
Vcf <- c(1:5)
x <- data.frame(class = Vcf, Ancfc=Ancfc,Ancfa=Ancfa,Lmcfc=Lmcfc,Lmcfa=Lmcfa)
kable(x,booktabs=T,digits=2, caption="Population frequencies accross carcass conformation classes (Kunz,2018)")

```

```{r weightthresh}
cwc <- 1.4
cwa <- c(2.9,3,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8)
```

#### Prices

```{r}
# average carcass numbers per month of categories MT, OB and RG in 2017 from Agristat S. 35.
MT <- 8535
OB <- 3460
RG <- 7137
MTfr <- MT/sum(MT,OB,RG)
OBfr <- OB/sum(MT,OB,RG)
RGfr <- RG/sum(MT,OB,RG)
# prices for categories KV, MT, OB and RG from Proviande 2018, week 33.
MTcc <- c(7.9,8.2,8.6,8.8,9.1,9.3,9.55)
OBcc <- c(7.9,8.2,8.6,8.8,9.1,9.4,9.65)
RGcc <- c(6.9,7.5,8.2,8.8,9.2,9.5,9.75)
ccc <- c(11.2,12.7,13.6,14.2,14.7,15.2,15.7)
cca <- MTcc*MTfr+OBcc*OBfr+RGcc*RGfr
# prices for categories KV, MT, OB and RG from Proviande 2018, week 33.
MTcf <- c(-0.9,-0.3,0,-0.3,-0.7)
OBcf <- c(-0.9, -0.3,0,-0.4,-0.9)
RGcf <- c(-0.9,-0.3,0,-0.5,-1)
cfc <- c(-1.5,-0.6,0,-0.4,-1)
cfa <- MTcf*MTfr+OBcf*OBfr+RGcf*RGfr
# prices for category KV from Proviande 2018, week 33.
cwc <- c(0,1.4)
# # prices for categories MT, OB and RG from Proviande 2016.
cwa <- c(0.1,0.2,0.3,0.5,0.7,0.9,1.2,1.4,1.6,1.8)
```

## Internal Function
```{r intfunceconomicvalue, eval=FALSE}
#' @title
#'
#' @description
#'
#' @param pvec_threshold   thresholds under continuous distribution given by pricing system
#' @param pvec_price       vector of prices for given classes
#' @param pn_mean          current population phenotypic mean
#' @param pn_sd            current population phenotypic standard deviation
#' @param pn_delta_mean    small change of current phenotypic population mean
#' @return economic value
compute_internal_economic_value <- function(pvec_threshold
                                            pvec_price,
                                            pn_mean,
                                            pn_sd,
                                            pn_delta_mean){
        # define new mean
        pn_mean_new <- pn_mean+pn_delta_mean
        # define frequencies for initial mean
        freq_pn_mean <- diff(c(0,pnorm(pvec_threshold,sd=pn_sd,mean=pn_mean, lower.tail = T)))
        # define frequencies for new mean
        freq_pn_mean_new <- diff(c(0,pnorm(pvec_threshold,sd=pn_sd,mean=pn_mean_new, lower.tail = T)))
        # compute economic weight
        ev_result <- (t(pvec_price)%*%freq_pn_mean_new-t(pvec_price)%*%freq_pn_mean)/pn_delta_mean
        return(ev_result)
      }
```


## General Function
The general function can be designed as follows

```{r funceconomicvalue, eval=FALSE}
#' @title
#'General function to compute an economic value for carcass fat, carcass conformation or carcass weight.
#' @description
#'This function 
#' @param pvec_class_freq  discrete empirical distribution of population for given trait over different classes
#' @param pvec_threshold   thresholds under continuous distribution given by pricing system
#' @param pvec_price       vector of prices for given classes
#' @param pn_mean          current population phenotypic mean
#' @param pn_sd            current population phenotypic standard deviation
#' @param pn_delta_mean    small change of current phenotypic population mean
#' @return economic value
compute_economic_value <- function( pvec_class_freq = NULL,
                                    pvec_threshold  = NULL,
                                    pvec_price,
                                    pn_mean,
                                    pn_sd,
                                    pn_delta_mean ){
  # general format requirements for input variables
  if(length(pn_mean)>1){
        cat("pn_mean must be one number")
         return()
      }
      if(length(pn_sd)>1){
        cat("pn_sd must be one number")
         return()
      }
      if(length(pn_delta_mean)>1){
        cat("pn_delta_mean must be one number")
         return()
      }
      if(pn_sd<0){
        cat("pn_sd must be positive")
         return()
      }
  if(is.null(pvec_class_freq)) {
    # case of carcass weight
    # computation of economic value for carcass weight
    # special format requirements for input variables
      if(length(pvec_threshold)!=length(pvec_price)-1){
        cat("pvec_threshold must be one vector element shorter than pvec_price ")
         return()
      }
      
        # fit threshold vector by adding infinity to its tail
        pvec_threshold <- c(pvec_threshold,Inf)
        # compute economic value 
        ev_result <- compute_internal_economic_value(pvec_threshold = pvec_threshold, 
                                                     pn_sd = pn_sd, pn_mean = pn_mean, pvec_price = pvec_price, 
                                                     pn_delta_mean = pn_delta_mean)
        return(ev_result)
        
      
        
  }else if(is.null(pvec_threshold)){
    # case of cf* and cc*
    # special format requirements for input variables
    if(length(pvec_class_freq)!=length(pvec_price)){
        cat("pvec_class_freq must be the same length as pvec_price. ")
         return()
      }
      # define thresholds within normal distribution
        pvec_threshold<- qnorm(cumsum(pvec_class_freq),sd=pn_sd,mean=pn_mean, lower.tail = T)
          # compute economic value
        ev_result <- compute_internal_economic_value(pvec_threshold = pvec_threshold, 
                                                     pn_sd = pn_sd, pn_mean = pn_mean, pvec_price = pvec_price, 
                                                     pn_delta_mean = pn_delta_mean)
    
      
  }
  
}

```

```{r computeev}
## read input
s_lm_cfc_freq_fname <- "lm_cfc_freq.csv"
tbl_lm_cfc_freq <- readr::read_table(s_lm_cfc_freq_fname)
tbl_lm_cfc_freq

### # mean and sd
s_mean_sd_fn <- "mean_sd.csv"
tbl_mean_sd <- readr::read_csv2(file = s_mean_sd_fn)
tbl_mean_sd

library(dplyr)
tbl_mean_sd %>% filter(Trait == "cfc") %>% filter(Breed == "lm") %>% select(Mean)


## specify frequencies instead of numbers in pvec_class_freq
compute_economic_value(pvec_class_freq = tbl_lm_cfc_freq$freq, pn_sd = 0.99, pn_mean = 5.48, pvec_price = c(11.2,12.7,13.6,14.2,14.7,15.2,15.7), pn_delta_mean = 0.01)

compute_economic_value(pvec_threshold = c(120,300), pn_sd = 45, pn_mean = 242, pvec_price = c(-10,0,-20), pn_delta_mean = 0.01)
```


## Carcass Weight
The following function computes the economic value of the trait age-adjusted __carcass weight__. The economic value is defined as the change in profit for a small change in the population mean of the trait.


```{r}
#' @title Compute Economic Value
#'
#' @description
#' The economic value of the trait is computed as profit per carcass weight.
#'
#' @param pn_profit the current value of the profit
#' @param pn_carcass_weight  the current population mean for caracass weight
#' @return pn_economic_value result of economic value
compute_economic_value <- function(pn_profit, pn_carcass_weight){
  # compute economic value
  pn_economic_value <- pn_profit / pn_carcass_weight
  return(pn_economic_value)
}
```

Now we are ready to test the defined function

```{r}
my_ev_result <- compute_economic_value(pn_profit = 384, pn_carcass_weight = 271.3)
my_ev_result
```


### Extended Version
```{r}
economic_value_profit <- function(pn_revenue = NA, pn_cost = NA, pn_carcass_weight){
  if (is.na(pn_cost)){
    pn_economic_value <- pn_revenue / pn_carcass_weight
  } else if (is.na(pn_revenue)) {
    pn_economic_value <- pn_cost / pn_carcass_weight
  }
}
```


In the current population, we have the following economic parameters.

$$G = E - K$$
where $G$ is profit, $E$ is revenue and $K$ is costs all per slaughter animal, respectively


$$E = p * SG$$

where $p$ is the price per kg carcass weight and $SG$ is the cracass weight. Hence

$$G = p * SG - K$$


Assume carcass weight is increased by $\Delta_{SG}=1$ kg and hence $SG^* = SG + \Delta_{SG}$

$$E^* = p * SG^*$$

The new profit corresponds to $G^*$
$$G^* = E^* - K = p * SG^* - K$$

The economic value $EV$ is defined as

$$EV = \frac{G^* - G}{\Delta_{SG}} = \frac{E^* - K - (E - K)}{\Delta_{SG}} = \frac{E^* - E}{\Delta_{SG}} = \frac{p * SG^* - p * SG}{\Delta_{SG}} = p$$


Our computation

$$\rho = \frac{G}{SG}$$

$$G^* = G + \rho * \Delta_{SG}$$





## Carcass Fat

```{r}
categorical_economic_value <- function(pvec_trait_distribution, pvec_trait_price){
  
}
```

